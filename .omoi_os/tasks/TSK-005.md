---
id: TSK-005
title: Implement rate limiting logic
status: pending
ticket_id: TKT-001
estimate: M
type: implementation
dependencies:
  depends_on:
    - TSK-002
  blocks:
    - TSK-003
---

# TSK-005: Implement rate limiting logic

## Objective

Implement rate limiting to prevent notification spam, tracking notification counts per user per hour.

## Context

Users shouldn't receive more than 10 notifications per hour (configurable). Rate-limited notifications are stored but not delivered via WebSocket.

## Deliverables

- [ ] `omoi_os/services/notification_rate_limiter.py` - NotificationRateLimiter class

## Implementation Notes

```python
# omoi_os/services/notification_rate_limiter.py

from uuid import UUID
from datetime import datetime, timedelta
from typing import Optional

from redis.asyncio import Redis
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from omoi_os.models.notification import Notification
from omoi_os.utils.datetime import utc_now


class NotificationRateLimiter:
    """Rate limiting for notifications."""

    RATE_LIMIT_PER_HOUR = 10
    RATE_WINDOW = timedelta(hours=1)

    def __init__(self, redis: Optional[Redis] = None):
        self.redis = redis

    async def is_rate_limited(
        self, db: AsyncSession, user_id: UUID, is_admin: bool = False
    ) -> bool:
        """Check if user is rate limited."""
        if is_admin:
            return False

        if self.redis:
            return await self._check_redis(user_id)
        else:
            return await self._check_database(db, user_id)

    async def _check_redis(self, user_id: UUID) -> bool:
        """Check rate limit using Redis."""
        key = f"notif_rate:{user_id}"
        count = await self.redis.incr(key)

        if count == 1:
            await self.redis.expire(key, int(self.RATE_WINDOW.total_seconds()))

        return count > self.RATE_LIMIT_PER_HOUR

    async def _check_database(self, db: AsyncSession, user_id: UUID) -> bool:
        """Check rate limit using database."""
        cutoff = utc_now() - self.RATE_WINDOW

        stmt = select(func.count(Notification.id)).where(
            Notification.user_id == user_id,
            Notification.created_at >= cutoff,
            Notification.delivered_via_ws == True,
        )

        result = await db.execute(stmt)
        count = result.scalar()

        return count >= self.RATE_LIMIT_PER_HOUR

    async def record_delivery(self, db: AsyncSession, user_id: UUID):
        """Record a notification delivery (for DB-based limiting)."""
        # Handled by NotificationService setting delivered_via_ws=True
        pass
```

## Acceptance Criteria

- [ ] NotificationRateLimiter with is_rate_limited method
- [ ] Redis-based counting if available
- [ ] Fallback to database counting
- [ ] 10 notifications per hour limit (configurable)
- [ ] Admin users exempt from rate limiting
- [ ] 1-hour rolling window
