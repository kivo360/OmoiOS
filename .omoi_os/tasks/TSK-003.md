---
id: TSK-003
title: Implement NotificationService core methods
status: pending
parent_ticket: TKT-001
estimate: L
type: implementation
dependencies:
  depends_on:
    - TSK-001
    - TSK-002
  blocks:
    - TSK-007
---

# TSK-003: Implement NotificationService core methods

## Objective

Create the NotificationService class with methods for creating, delivering, and managing notifications.

## Context

NotificationService is the core of the notification system. It handles notification creation, preference checking, rate limiting, and delivery coordination.

## Deliverables

- [ ] `omoi_os/services/notification_service.py` - NotificationService class

## Implementation Notes

```python
# omoi_os/services/notification_service.py

from uuid import UUID
from typing import Optional, Dict, Any
from datetime import timedelta

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from omoi_os.models.notification import Notification, NotificationPreference
from omoi_os.services.database import DatabaseService
from omoi_os.utils.datetime import utc_now


class NotificationService:
    """Core service for notification creation and delivery."""

    AGGREGATION_WINDOW = timedelta(minutes=5)
    RATE_LIMIT_PER_HOUR = 10

    def __init__(
        self,
        db: DatabaseService,
        ws_manager: Optional["WebSocketManager"] = None,
    ):
        self.db = db
        self.ws_manager = ws_manager

    async def create_notification(
        self,
        user_id: UUID,
        type: str,
        title: str,
        message: str,
        data: Dict[str, Any],
    ) -> Optional[Notification]:
        """Create and deliver a notification."""
        # 1. Check preferences
        prefs = await self._get_preferences(user_id)
        if not self._should_notify(prefs, type):
            return None

        # 2. Check rate limits
        if await self._is_rate_limited(user_id):
            return await self._create_silent(user_id, type, title, message, data)

        # 3. Create notification
        notification = await self._create_in_db(user_id, type, title, message, data)

        # 4. Deliver
        if prefs.in_app_enabled(type):
            await self._deliver_websocket(notification)

        return notification

    async def get_notifications(
        self,
        user_id: UUID,
        status: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> tuple[list[Notification], int]:
        """Get notifications for user with pagination."""
        # Implementation...

    async def mark_as_read(self, notification_id: UUID, user_id: UUID) -> bool:
        """Mark notification as read."""
        # Implementation...

    async def get_unread_count(self, user_id: UUID) -> int:
        """Get unread notification count for user."""
        # Implementation...

    async def _get_preferences(self, user_id: UUID) -> NotificationPreference:
        """Get user preferences with defaults."""
        # Implementation...

    def _should_notify(self, prefs: NotificationPreference, type: str) -> bool:
        """Check if notification type is enabled."""
        # Implementation...

    async def _is_rate_limited(self, user_id: UUID) -> bool:
        """Check if user is rate limited."""
        # Implementation...

    async def _create_in_db(
        self, user_id: UUID, type: str, title: str, message: str, data: Dict[str, Any]
    ) -> Notification:
        """Create notification in database."""
        # Implementation...

    async def _deliver_websocket(self, notification: Notification):
        """Deliver notification via WebSocket."""
        if self.ws_manager:
            await self.ws_manager.broadcast_to_user(
                str(notification.user_id),
                {"type": "notification_new", "payload": notification.to_dict()}
            )
```

## Acceptance Criteria

- [ ] NotificationService with create_notification method
- [ ] Preference checking before notification creation
- [ ] Rate limiting using Redis or PostgreSQL
- [ ] Database operations use async SQLAlchemy patterns
- [ ] WebSocket delivery via existing WebSocketManager
- [ ] Support for silent notifications (rate limited)
- [ ] All methods have proper error handling
