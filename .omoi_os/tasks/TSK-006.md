---
id: TSK-006
title: Implement notification cleanup job
status: pending
parent_ticket: TKT-001
estimate: M
type: implementation
dependencies:
  depends_on:
    - TSK-002
  blocks: []
---

# TSK-006: Implement notification cleanup job

## Objective

Create a background job that deletes old read notifications when a user exceeds 1000 notifications.

## Context

To prevent unlimited database growth, old read notifications should be automatically cleaned up, always keeping at least 100 recent notifications.

## Deliverables

- [ ] `omoi_os/jobs/notification_cleanup.py` - NotificationCleanupJob class

## Implementation Notes

```python
# omoi_os/jobs/notification_cleanup.py

from uuid import UUID
from typing import List
from datetime import datetime

from sqlalchemy import select, func, delete
from sqlalchemy.ext.asyncio import AsyncSession

from omoi_os.models.notification import Notification
from omoi_os.models.user import User
from omoi_os.services.database import DatabaseService
from omoi_os.utils.datetime import utc_now


class NotificationCleanupJob:
    """Background job to clean up old notifications."""

    MAX_NOTIFICATIONS = 1000
    MIN_KEEP = 100

    def __init__(self, db: DatabaseService):
        self.db = db

    async def run(self):
        """Run the cleanup job."""
        with self.db.get_session() as session:
            # Find users with too many notifications
            user_ids = await self._find_users_to_cleanup(session)

            for user_id in user_ids:
                await self._cleanup_user(session, user_id)

            await session.commit()

    async def _find_users_to_cleanup(self, session: AsyncSession) -> List[UUID]:
        """Find users who exceed notification limit."""
        stmt = select(Notification.user_id).group_by(
            Notification.user_id
        ).having(
            func.count(Notification.id) > self.MAX_NOTIFICATIONS
        )

        result = await session.execute(stmt)
        return [row[0] for row in result.all()]

    async def _cleanup_user(self, session: AsyncSession, user_id: UUID):
        """Clean up old notifications for a user."""
        # Get total count
        count_stmt = select(func.count(Notification.id)).where(
            Notification.user_id == user_id,
            Notification.status == "read",
        )
        result = await session.execute(count_stmt)
        read_count = result.scalar()

        if read_count <= self.MIN_KEEP:
            return

        # Find oldest read notifications to delete
        # Keep MIN_KEEP most recent
        delete_count = read_count - self.MIN_KEEP

        # Get IDs of notifications to delete
        find_stmt = select(Notification.id).where(
            Notification.user_id == user_id,
            Notification.status == "read",
        ).order_by(
            Notification.created_at.desc()
        ).offset(self.MIN_KEEP).limit(delete_count)

        result = await session.execute(find_stmt)
        ids_to_delete = [row[0] for row in result.all()]

        # Soft delete
        if ids_to_delete:
            delete_stmt = delete(Notification).where(
                Notification.id.in_(ids_to_delete)
            )
            await session.execute(delete_stmt)

    async def get_stats(self) -> dict:
        """Get cleanup statistics."""
        with self.db.get_session() as session:
            total_stmt = select(func.count(Notification.id))
            result = await session.execute(total_stmt)
            total = result.scalar()

            users_stmt = select(func.count(func.distinct(Notification.user_id)))
            result = await session.execute(users_stmt)
            users = result.scalar()

            return {
                "total_notifications": total,
                "users_with_notifications": users,
            }
```

## Acceptance Criteria

- [ ] NotificationCleanupJob with run method
- [ ] Deletes oldest read notifications when count exceeds 1000
- [ ] Always keeps minimum 100 most recent notifications
- [ ] Only deletes read notifications
- [ ] Uses soft delete (sets deleted_at)
- [ ] Returns cleanup statistics
- [ ] Can be scheduled as recurring job
