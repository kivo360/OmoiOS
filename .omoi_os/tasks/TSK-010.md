---
id: TSK-010
title: Implement PlaybookPromoter for playbook integration
status: pending
created: 2025-01-08
parent_ticket: TKT-002
estimate: M
type: implementation
dependencies:
  depends_on: [TSK-002, TSK-003]
  blocks: []
---

# TSK-010: Implement PlaybookPromoter for playbook integration

## Objective

Implement the playbook promoter that automatically promotes high-value consolidated memories to playbook entries.

## Context

High-quality consolidated memories should be promoted to the playbook so they're easily accessible to agents.

## Deliverables

- `backend/omoi_os/services/consolidation/playbook_promoter.py` - PlaybookPromoter class

## Implementation Notes

```python
# omoi_os/services/consolidation/playbook_promoter.py
from typing import Optional
from sqlalchemy.orm import Session

from omoi_os.models.task_memory import TaskMemory
from omoi_os.models.playbook_entry import PlaybookEntry

class PlaybookPromoter:
    async def promote_to_playbook(
        self,
        session: Session,
        memory_id: str,
        confidence: float,
    ) -> Optional[str]:
        """
        Promote a consolidated memory to playbook.

        Criteria:
        - Memory type is 'consolidated' or 'synthesis'
        - Confidence > threshold (default 0.85)
        - Not already in playbook

        Returns playbook entry ID if promoted, None otherwise.
        """
        memory = session.get(TaskMemory, memory_id)
        if not memory:
            return None

        # Check eligibility
        if memory.memory_type not in ("consolidated", "synthesis"):
            return None

        if confidence < 0.85:
            return None

        # Check for duplicates
        if await self._check_playbook_duplicate(
            session, memory.execution_summary, memory.project_id
        ):
            return None

        # Create playbook entry
        entry = PlaybookEntry(
            project_id=memory.project_id,
            content=memory.execution_summary,
            category=self._infer_category(memory),
            tags=memory.tags or [],
            priority=self._calculate_priority(memory),
            supporting_memory_ids=[memory_id],
            embedding=memory.context_embedding,
            created_by="consolidation_system",
        )

        session.add(entry)
        session.flush()

        return str(entry.id)

    def _infer_category(self, memory: TaskMemory) -> str:
        """Infer playbook category from memory content."""
        # Simple keyword matching
        content_lower = memory.execution_summary.lower()
        if any(w in content_lower for w in ["error", "fix", "bug"]):
            return "gotchas"
        elif any(w in content_lower for w in ["pattern", "architecture", "design"]):
            return "architecture"
        elif any(w in content_lower for w in ["best practice", "recommend", "should"]):
            return "patterns"
        else:
            return "general"

    def _calculate_priority(self, memory: TaskMemory) -> int:
        """Calculate playbook entry priority."""
        base = 50
        if memory.synthesis_confidence:
            base += int(memory.synthesis_confidence * 50)
        return min(100, base)
```

## Acceptance Criteria

- [ ] PlaybookPromoter class with promote_to_playbook() method
- [ ] Validates memory type (consolidated/synthesis only)
- [ ] Checks confidence threshold
- [ ] Checks for duplicate playbook entries
- [ ] Infers category from content
- [ ] Calculates priority based on confidence
- [ ] Creates PlaybookEntry with supporting_memory_ids
- [ ] Returns entry ID or None
- [ ] Unit tests for various scenarios

## Dependencies

**Depends On**: TSK-002, TSK-003
**Blocks**: None

## Estimate

**Size**: M (2-4 hours)
