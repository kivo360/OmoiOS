---
id: TSK-004
title: Implement NotificationAggregator
status: pending
parent_ticket: TKT-001
estimate: M
type: implementation
dependencies:
  depends_on:
    - TSK-001
    - TSK-002
  blocks:
    - TSK-003
---

# TSK-004: Implement NotificationAggregator

## Objective

Create the NotificationAggregator class that groups similar notifications within a time window to prevent spam.

## Context

Multiple similar notifications (e.g., 5 tickets assigned in 5 minutes) should be aggregated into a single notification like "5 tickets assigned to you".

## Deliverables

- [ ] `omoi_os/services/notification_aggregator.py` - NotificationAggregator class

## Implementation Notes

```python
# omoi_os/services/notification_aggregator.py

from uuid import UUID
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta

from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from omoi_os.models.notification import Notification
from omoi_os.utils.datetime import utc_now


class NotificationAggregator:
    """Aggregates similar notifications within a time window."""

    AGGREGATION_WINDOW = timedelta(minutes=5)
    AGGREGATABLE_TYPES = {
        "ticket_assigned",
        "task_completed",
    }

    async def maybe_aggregate(
        self,
        db: AsyncSession,
        user_id: UUID,
        type: str,
        title: str,
        message: str,
        data: Dict[str, Any],
    ) -> Optional[Notification]:
        """Check if we should aggregate with existing notifications."""
        if type not in self.AGGREGATABLE_TYPES:
            return None

        cutoff = utc_now() - self.AGGREGATION_WINDOW
        recent = await self._find_recent_notifications(db, user_id, type, cutoff)

        if not recent:
            return None

        groups = self._group_by_key(recent, data)
        for key, group in groups.items():
            if len(group) >= 2:
                return await self._create_aggregated(db, group, data)

        return None

    async def _find_recent_notifications(
        self, db: AsyncSession, user_id: UUID, type: str, cutoff: datetime
    ) -> List[Notification]:
        """Find recent notifications of the same type."""
        stmt = select(Notification).where(
            and_(
                Notification.user_id == user_id,
                Notification.type == type,
                Notification.created_at >= cutoff,
                Notification.status == "unread",
                Notification.aggregation_id.is_(None),
            )
        )
        result = await db.execute(stmt)
        return list(result.scalars().all())

    def _group_by_key(
        self, notifications: List[Notification], data: Dict[str, Any]
    ) -> Dict[str, List[Notification]]:
        """Group notifications by aggregation key."""
        groups: Dict[str, List[Notification]] = {}
        for notif in notifications:
            key = self._get_aggregation_key(notif, data)
            groups.setdefault(key, []).append(notif)
        return groups

    def _get_aggregation_key(self, notification: Notification, data: Dict[str, Any]) -> str:
        """Get aggregation key for notification."""
        # For ticket_assigned, group by assigner_id
        if notification.type == "ticket_assigned":
            return str(data.get("assigner_id", ""))
        return ""

    async def _create_aggregated(
        self, db: AsyncSession, group: List[Notification], data: Dict[str, Any]
    ) -> Notification:
        """Create aggregated notification."""
        count = len(group)
        type = group[0].type

        if type == "ticket_assigned":
            title = f"{count} tickets assigned to you"
            message = f"You have {count} new ticket assignments"
        else:
            title = f"{count} updates"
            message = f"You have {count} new notifications"

        aggregation_id = UUID("00000000-0000-0000-0000-000000000000")  # Generate or use first

        # Create aggregated notification
        aggregated = Notification(
            user_id=group[0].user_id,
            type=type,
            title=title,
            message=message,
            data={"count": count, "notifications": [n.id for n in group]},
            aggregation_id=aggregation_id,
        )

        # Update original notifications
        for notif in group:
            notif.aggregation_id = aggregation_id

        db.add(aggregated)
        await db.commit()
        await db.refresh(aggregated)

        return aggregated
```

## Acceptance Criteria

- [ ] NotificationAggregator with maybe_aggregate method
- [ ] 5-minute aggregation window
- [ ] Groups by aggregation key (e.g., assigner_id)
- [ ] Only aggregates when 2+ similar notifications exist
- [ ] Creates aggregated notification with count
- [ ] Links original notifications via aggregation_id
- [ ] Configurable aggregatable types
