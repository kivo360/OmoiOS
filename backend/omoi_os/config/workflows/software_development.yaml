# Software Development Workflow Configuration
# Hephaestus-inspired adaptive workflow with done definitions and discovery tracking

name: "Software Development"
has_result: true
result_criteria: "All components implemented, tested, and deployed"
on_result_found: "stop_all"

phases:
  - id: "PHASE_REQUIREMENTS"
    name: "Requirements Analysis"
    description: "Extract requirements from PRD and identify components"
    sequence_order: 1
    allowed_transitions:
      - "PHASE_DESIGN"
      - "PHASE_BLOCKED"
    is_terminal: false
    
    done_definitions:
      - "Requirements extracted and documented"
      - "Components identified and listed"
      - "Ticket moved to 'analyzing' status"
      - "Phase 2 implementation tasks created with ticket links"
      - "All spawned tasks include ticket ID in description"
    
    expected_outputs:
      - type: "documentation"
        pattern: "requirements/*.md"
        required: true
      - type: "task"
        pattern: "Phase 2 tasks created"
        required: true
    
    phase_prompt: |
      YOU ARE IN THE REQUIREMENTS ANALYSIS PHASE
      
      STEP 1: Extract ticket ID from task description (format: "TICKET: ticket-xxx" or from task.ticket_id)
      STEP 2: Read the PRD.md carefully
      STEP 3: Extract functional and non-functional requirements
      STEP 4: Identify system components (auth, API, frontend, database, etc.)
      STEP 5: Move ticket to 'analyzing' status
        change_ticket_status(ticket_id="ticket-xxx", new_status="analyzing", comment="Requirements analysis in progress")
      STEP 6: For each component, create a Phase 2 implementation task with ticket link
        create_task({
          "ticket_id": "ticket-xxx",
          "phase_id": "PHASE_IMPLEMENTATION",
          "description": "Phase 2: Implement [Component] - TICKET: ticket-xxx"
        })
      STEP 7: Document requirements in requirements/ directory
      STEP 8: Mark task as done
      
      IMPORTANT: Do not proceed until all done_definitions are met.
      Create one implementation task per component discovered.
      Always include ticket ID in task descriptions for context threading.
    
    next_steps_guide:
      - "Phase 2 agents will implement each component in parallel"
      - "Each implementation spawns its own Phase 3 validation task"
      - "If requirements are unclear, spawn clarification tasks"
  
  - id: "PHASE_IMPLEMENTATION"
    name: "Implementation"
    description: "Build one component with comprehensive tests"
    sequence_order: 3
    allowed_transitions:
      - "PHASE_TESTING"
      - "PHASE_REQUIREMENTS"  # Jump back if clarification needed
      - "PHASE_BLOCKED"
    is_terminal: false
    
    done_definitions:
      - "Ticket moved to 'building' status"
      - "Component code files created in src/"
      - "Minimum 3 test cases written"
      - "Tests passing locally"
      - "Ticket moved to 'building-done' status"
      - "Phase 3 validation task created with ticket link"
      - "update_task_status called with status='done'"
    
    expected_outputs:
      - type: "file"
        pattern: "src/**/*.py"
        required: true
      - type: "test"
        pattern: "tests/test_*.py"
        required: true
        validation_rule: "min_passing: 3"
    
    phase_prompt: |
      YOU ARE A SOFTWARE ENGINEER IN THE IMPLEMENTATION PHASE
      
      STEP 1: Extract ticket ID from task description (format: "TICKET: ticket-xxx" or from task.ticket_id)
      STEP 2: Move ticket to 'building' status
        change_ticket_status(ticket_id="ticket-xxx", new_status="building", comment="Implementation started")
      STEP 3: Understand the component requirements from the ticket
      STEP 4: Design the interface and data structures
      STEP 5: Implement the core logic
      STEP 6: Write comprehensive tests (minimum 3 test cases)
      STEP 7: Run tests and ensure they pass
      
      IF you discover bugs:
        - Use discovery_service.record_discovery_and_branch() to spawn immediate fix task
        - Continue your implementation work (don't stop)
        - Fix task will be handled separately
      
      IF you discover optimizations:
        - Use discovery_service.record_discovery_and_branch() to spawn investigation task
        - Continue your implementation work
      
      IF requirements are unclear or missing:
        - JUMP BACK to Phase 1 for clarification:
          discovery_service.record_discovery_and_branch(
            discovery_type="clarification_needed",
            spawn_phase_id="PHASE_REQUIREMENTS",  # Phase jumping - bypasses allowed_transitions
            spawn_description="Clarify [What's unclear] - Needed for [Component] - TICKET: ticket-xxx"
          )
        - Mark your task as blocked until clarification received
        - update_task_status(task_id="current-task-id", status="blocked", error_message="Waiting for requirements clarification")
      
      STEP 8: Move ticket to 'building-done' status
        change_ticket_status(ticket_id="ticket-xxx", new_status="building-done", comment="Implementation complete, ready for validation")
      STEP 9: Create Phase 3 validation task with ticket link
        discovery_service.record_discovery_and_branch(
          discovery_type="new_component",
          spawn_phase_id="PHASE_TESTING",
          spawn_description="Phase 3: Validate [Component] - TICKET: ticket-xxx"
        )
      STEP 10: Mark task as done
      
      IMPORTANT: 
      - All done_definitions must be met before marking complete
      - Continue your work after spawning discovery tasks (don't stop)
      - Always include ticket ID in spawned task descriptions for context threading
      - Discovery-based spawning can target ANY phase (bypasses allowed_transitions)
    
    next_steps_guide:
      - "Phase 3 agent runs integration tests on your component"
      - "If tests pass ‚Üí component validated ‚Üí marked complete"
      - "If tests fail ‚Üí bugs spawned back to Phase 2"
      - "Discoveries during testing may spawn parallel investigations"
  
  - id: "PHASE_TESTING"
    name: "Validation & Testing"
    description: "Run integration tests and validate requirements"
    sequence_order: 4
    allowed_transitions:
      - "PHASE_DEPLOYMENT"
      - "PHASE_IMPLEMENTATION"  # Loop back if bugs found
      - "PHASE_BLOCKED"
    is_terminal: false
    
    done_definitions:
      - "Ticket moved to 'testing' status"
      - "Integration tests executed"
      - "If tests PASS: Ticket moved to 'done' status"
      - "If tests FAIL: Phase 2 fix task created (feedback loop)"
      - "Requirements validated"
      - "If bugs found ‚Üí fix tasks created with ticket links"
      - "If no bugs ‚Üí deployment task created (if needed)"
    
    expected_outputs:
      - type: "test"
        pattern: "tests/integration/*.py passing"
        required: true
      - type: "task"
        pattern: "Phase 4 deployment task OR Phase 2 fix tasks created"
        required: true
    
    phase_prompt: |
      YOU ARE A QA ENGINEER IN THE VALIDATION PHASE
      
      STEP 1: Extract ticket ID from task description (format: "TICKET: ticket-xxx" or from task.ticket_id)
      STEP 2: Move ticket to 'testing' status
        change_ticket_status(ticket_id="ticket-xxx", new_status="testing", comment="Validation started")
      STEP 3: Review the component implementation
      STEP 4: Run integration tests
      STEP 5: Validate against requirements
      
      IF tests PASS:
        - Move ticket to 'done' status
          change_ticket_status(ticket_id="ticket-xxx", new_status="done", comment="All tests passing, component validated")
        - Create Phase 4 deployment task with ticket link (if deployment needed)
        - Mark validation task as done
      
      IF tests FAIL:
        - Spawn Phase 2 fix task via DiscoveryService (FEEDBACK LOOP):
          discovery_service.record_discovery_and_branch(
            discovery_type="bug_found",
            spawn_phase_id="PHASE_IMPLEMENTATION",  # Loop back to Phase 2
            spawn_description="Fix bugs in [Component] - [Specific errors] - TICKET: ticket-xxx",
            priority_boost=True  # Boost priority for fixes
          )
        - Keep ticket in 'testing' status (don't move to done)
        - Mark your validation task as done (validation complete, found issues)
        - Fix task will spawn new validation task when complete
        - LOOP: New validation task ‚Üí If fails ‚Üí Spawn fix ‚Üí Re-validate until passing
      
      IF you discover optimization opportunities:
        - Use discovery_service.record_discovery_and_branch() to spawn investigation task
        - Continue your validation work (don't stop)
        - Investigation can spawn Phase 1 analysis or Phase 2 implementation tasks
      
      IF you discover security issues:
        - Spawn critical priority fix task immediately
        - Use discovery_service.record_discovery_and_branch() with priority_boost=True
        - Continue validation work
      
      DISCOVERY PATTERNS:
      - Bug discovered ‚Üí spawn fix task (Phase 2, priority boost) ‚Üí fix spawns new validation ‚Üí loop until passing
      - Performance issue ‚Üí spawn optimization investigation (can spawn Phase 1 or Phase 2 tasks)
      - Security issue ‚Üí spawn security fix (critical priority, Phase 2)
      - Integration issue ‚Üí spawn integration fix task (Phase 2)
      
      IMPORTANT: 
      - Do not approve buggy components. Spawn fixes instead.
      - Feedback loop: validation ‚Üí fix ‚Üí re-validate until passing
      - Continue your validation work after spawning discovery tasks
      - Always include ticket ID in spawned task descriptions for context threading
    
    next_steps_guide:
      - "If all tests pass ‚Üí Phase 4 deploys the component"
      - "If bugs found ‚Üí Phase 2 fixes them ‚Üí re-test loop"
      - "Workflow branches naturally based on test results"

  - id: "PHASE_DEPLOYMENT"
    name: "Deployment"
    description: "Deploy validated component to production"
    sequence_order: 5
    allowed_transitions:
      - "PHASE_DONE"
      - "PHASE_BLOCKED"
    is_terminal: false
    
    done_definitions:
      - "Component deployed successfully"
      - "Deployment verified"
      - "Monitoring enabled"
      - "Ticket marked as 'done'"
    
    expected_outputs:
      - type: "deployment"
        pattern: "deployment successful"
        required: true
    
    phase_prompt: |
      YOU ARE A DEVOPS ENGINEER IN THE DEPLOYMENT PHASE
      
      STEP 1: Verify component is validated (all tests passing)
      STEP 2: Deploy to production
      STEP 3: Verify deployment health
      STEP 4: Enable monitoring
      STEP 5: Mark ticket as done
    
    next_steps_guide:
      - "Component is now in production"
      - "Ticket moves to DONE status"
      - "Workflow complete for this component"

  - id: "PHASE_DONE"
    name: "Done"
    description: "Component complete and deployed"
    sequence_order: 6
    allowed_transitions: []
    is_terminal: true
    
    done_definitions:
      - "Component in production"
      - "All validation passed"
    
    expected_outputs: []
    phase_prompt: "Component successfully completed."
    next_steps_guide: []

  - id: "PHASE_BLOCKED"
    name: "Blocked"
    description: "Blocked by external dependencies"
    sequence_order: 7
    allowed_transitions:
      - "PHASE_REQUIREMENTS"
      - "PHASE_IMPLEMENTATION"
      - "PHASE_TESTING"
    is_terminal: true
    
    done_definitions:
      - "Blocker identified and documented"
      - "Blocker resolution plan created"
    
    expected_outputs: []
    phase_prompt: "Identify blocker and create resolution plan."
    next_steps_guide:
      - "Once blocker resolved, move back to appropriate phase"

board_columns:
  - id: "backlog"
    name: "üìã Backlog"
    description: "Tickets awaiting analysis"
    sequence_order: 0
    phase_mapping:
      - "PHASE_BACKLOG"
    wip_limit: null
    is_terminal: false
    auto_transition_to: null
    color_theme: "gray"
  
  - id: "analyzing"
    name: "üîç Analyzing"
    description: "Requirements analysis and design"
    sequence_order: 1
    phase_mapping:
      - "PHASE_REQUIREMENTS"
      - "PHASE_DESIGN"
    wip_limit: 5
    is_terminal: false
    auto_transition_to: null
    color_theme: "blue"
  
  - id: "building"
    name: "üî® Building"
    description: "Active implementation work"
    sequence_order: 2
    phase_mapping:
      - "PHASE_IMPLEMENTATION"
    wip_limit: 10
    is_terminal: false
    auto_transition_to: "testing"
    color_theme: "yellow"
  
  - id: "testing"
    name: "üß™ Testing"
    description: "Validation and quality assurance"
    sequence_order: 3
    phase_mapping:
      - "PHASE_TESTING"
    wip_limit: 8
    is_terminal: false
    auto_transition_to: null
    color_theme: "blue"
  
  - id: "deploying"
    name: "üöÄ Deploying"
    description: "Ready for deployment"
    sequence_order: 4
    phase_mapping:
      - "PHASE_DEPLOYMENT"
    wip_limit: 3
    is_terminal: false
    auto_transition_to: "done"
    color_theme: "green"
  
  - id: "done"
    name: "‚úÖ Done"
    description: "Completed tickets"
    sequence_order: 5
    phase_mapping:
      - "PHASE_DONE"
    wip_limit: null
    is_terminal: true
    auto_transition_to: null
    color_theme: "green"
  
  - id: "blocked"
    name: "üö´ Blocked"
    description: "Blocked by dependencies"
    sequence_order: 6
    phase_mapping:
      - "PHASE_BLOCKED"
    wip_limit: null
    is_terminal: true
    auto_transition_to: null
    color_theme: "red"

